// Generated by CoffeeScript 1.10.0
(function() {
  var Equation, root,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Equation = (function() {
    Equation.shortcuts = {
      '[': '(',
      ']': ')',
      "'": '*',
      ';': '+',
      '`': "'",
      'up': '^(',
      'down': '_'
    };

    Equation.symbolregex = {
      '===': '≡',
      '~~': '≈',
      '!=': '≠',
      '=/=': '≠',
      '>=': '≥',
      '!<': '≮',
      '!>': '≯',
      '<-': '←',
      '->': '→',
      '<==': '⇐',
      '==>': '⇒',
      '\\+/-': '±',
      '\\*': '×',
      '\\^\\^': '\u0302'
    };

    Equation.symbol2regex = {
      '<=': '≤'
    };

    Equation.letterregex = {
      'Alpha': 'Α',
      'alpha': 'α',
      'Beta': 'Β',
      'beta': 'β',
      'Gamma': 'Γ',
      'gamma': 'γ',
      'Delta': 'Δ',
      'delta': 'δ',
      'Epsilon': 'Ε',
      'epsilon': 'ε',
      'Zeta': 'Ζ',
      'zeta': 'ζ',
      'Eta': 'Η',
      'Theta': 'Θ',
      'theta': 'θ',
      'Iota': 'Ι',
      'iota': 'ι',
      'Kappa': 'Κ',
      'kappa': 'κ',
      'Lambda': 'Λ',
      'lambda': 'λ',
      'Mu': 'Μ',
      'mu': 'μ',
      'Nu': 'Ν',
      'nu': 'ν',
      'Xi': 'Ξ',
      'xi': 'ξ',
      'Omicron': 'Ο',
      'omicron': 'ο',
      'Pi': 'Π',
      'pi': 'π',
      'Rho': 'Ρ',
      'rho': 'ρ',
      'Sigma': 'Σ',
      'sigma': 'σ',
      'Tau': 'Τ',
      'tau': 'τ',
      'Upsilon': 'Υ',
      'upsilon': 'υ',
      'Phi': 'Φ',
      'phi': 'φ',
      'Chi': 'Χ',
      'chi': 'χ',
      'Psi': 'Ψ',
      'Omega': 'Ω',
      'omega': 'ω',
      'inf': '∞'
    };

    Equation.letter2regex = {
      'eta': 'η',
      'psi': 'ψ',
      'del': '∇'
    };

    Equation.opregex = {
      'lim': '\\lim',
      'sqrt': '√',
      'int': '∫',
      'sum': '∑',
      'prod': '∏'
    };

    Equation.specialops = ['^', '_', '/', '√', '∫', '∑', '∏'];

    Equation.functions = ['exp', 'log', 'ln', 'sinc'];

    Equation.trigfunctions = ['sin', 'cos', 'tan', 'csc', 'sec', 'cot'];

    (function() {
      var func, k, len, ref, results;
      ref = Equation.trigfunctions;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        func = ref[k];
        Equation.functions.push(func);
        Equation.functions.push("a" + func);
        Equation.functions.push(func + "h");
        results.push(Equation.functions.push("a" + func + "h"));
      }
      return results;
    })();

    Equation.funcops = Object.keys(Equation.opregex).concat(Equation.functions);

    Equation.filters = ['\\$', '\\{', '\\}', 'bo', 'it', 'bi', 'sc', 'fr', 'ov', 'table', 'text', 'html', ',', ':', ';'];

    function Equation(inputBox, equationBox, resizeText, callback) {
      this.inputBox = inputBox;
      this.equationBox = equationBox;
      this.resizeText = resizeText != null ? resizeText : false;
      this.callback = callback != null ? callback : null;
      this.searchHandler = bind(this.searchHandler, this);
      this.keyUpHandler = bind(this.keyUpHandler, this);
      this.keyPressHandler = bind(this.keyPressHandler, this);
      this.keyDownHandler = bind(this.keyDownHandler, this);
      this.fontSize = parseFloat(this.equationBox.style.fontSize);
      this.message = this.equationBox.innerHTML;
      this.keys = [];
      this.powerTimeout = setTimeout((function() {}), 0);
      this.enable();
    }

    Equation.prototype.findAndReplace = function(string, object) {
      var i, j, regex;
      for (i in object) {
        j = object[i];
        regex = new RegExp(i, 'g');
        string = string.replace(regex, j);
      }
      return string;
    };

    Equation.prototype.findAllIndexes = function(source, find) {
      var i, k, ref, result;
      result = [];
      for (i = k = 0, ref = source.length - 1; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        if (source.slice(i, i + find.length) === find) {
          result.push(i);
        }
      }
      return result;
    };

    Equation.prototype.findBracket = function(string, startPos, opening) {
      var count, i, k, l, len, m, range, ref, results, results1;
      if (opening == null) {
        opening = false;
      }
      count = 0;
      if (opening) {
        range = (function() {
          results = [];
          for (var k = startPos; startPos <= 0 ? k <= 0 : k >= 0; startPos <= 0 ? k++ : k--){ results.push(k); }
          return results;
        }).apply(this);
      } else {
        range = (function() {
          results1 = [];
          for (var l = startPos, ref = string.length; startPos <= ref ? l < ref : l > ref; startPos <= ref ? l++ : l--){ results1.push(l); }
          return results1;
        }).apply(this);
      }
      for (m = 0, len = range.length; m < len; m++) {
        i = range[m];
        if (string[i] === '(') {
          count += 1;
        }
        if (string[i] === ')') {
          count -= 1;
        }
        if (count === 0) {
          return i;
        }
      }
    };

    Equation.prototype.parseMatrices = function(string) {
      var bracketEnd, c, idx, innerBracketStart, k, rowEnd, rowStart, rows, s, table;
      s = string;
      for (idx = k = s.length - 1; k >= 0; idx = k += -1) {
        c = s[idx];
        if (s.slice(idx, idx + 2) === '((') {
          bracketEnd = this.findBracket(s, idx);
          innerBracketStart = this.findBracket(s, bracketEnd - 1, true);
          if (s[innerBracketStart - 1] === ',' || innerBracketStart === idx + 1) {
            rows = [];
            rowStart = idx + 1;
            while (true) {
              rowEnd = this.findBracket(s, rowStart);
              rows.push(s.slice(rowStart + 1, rowEnd));
              if (s[rowEnd + 1] === ',') {
                rowStart = rowEnd + 2;
              } else {
                break;
              }
            }
            table = "(\\table " + (rows.join(';')) + ")";
            s = s.slice(0, idx) + table + s.slice(bracketEnd + 1);
          }
        }
      }
      return s;
    };

    Equation.prototype.parseOverbars = function(string) {
      var bracketEnd, bracketStart, c, idx, k, s;
      s = string;
      for (idx = k = s.length - 1; k >= 0; idx = k += -1) {
        c = s[idx];
        if (s.slice(idx, idx + 2) === '^_' && idx > 0) {
          s = s.slice(0, idx) + s.slice(idx + 2);
          if (s[idx - 1] === ')') {
            bracketEnd = idx - 1;
            bracketStart = this.findBracket(s, bracketEnd, true);
            if (bracketStart == null) {
              continue;
            }
          } else {
            bracketEnd = idx + 1;
            bracketStart = idx - 1;
            while (bracketStart - 1 >= 0 && !isNaN(Number(s.slice(bracketStart - 1, idx)))) {
              bracketStart -= 1;
            }
            s = s.slice(0, bracketStart) + "(" + s.slice(bracketStart, bracketEnd - 1) + ")" + s.slice(bracketEnd - 1);
          }
          s = this.changeBrackets(s, bracketStart, bracketEnd, '\\ov');
        }
      }
      return s;
    };

    Equation.prototype.parseFunction = function(string, func) {
      var endPos, i, indexes, k, len, ref, ref1, startPos;
      indexes = this.findAllIndexes(string, func);
      ref = indexes.reverse();
      for (k = 0, len = ref.length; k < len; k++) {
        i = ref[k];
        if (string[i - 1] === 'a' && (ref1 = func.slice(0, 3), indexOf.call(Equation.trigfunctions, ref1) >= 0)) {
          continue;
        }
        startPos = i + func.length;
        if (string[startPos] === '(') {
          endPos = this.findBracket(string, startPos);
          if (endPos) {
            string = (this.removeSlashes(string.slice(0, i))) + "{\\" + (this.removeSlashes(string.slice(i, +endPos + 1 || 9e9))) + "}" + string.slice(endPos + 1);
          } else {
            string = (this.removeSlashes(string.slice(0, i))) + "{\\" + (this.removeSlashes(string.slice(i)));
          }
        }
      }
      return string;
    };

    Equation.prototype.parseOperator = function(string, op) {
      var args, argsList, endPos, hasPower, i, indexes, k, len, over, ref, startPos, under;
      indexes = this.findAllIndexes(string, op);
      ref = indexes.reverse();
      for (k = 0, len = ref.length; k < len; k++) {
        i = ref[k];
        startPos = i + op.length;
        if (string[startPos] === '(') {
          endPos = this.findBracket(string, startPos);
          if (endPos) {
            hasPower = string[endPos + 1] === '^';
            if (op === 'lim') {
              string = this.changeBrackets(string, startPos, endPos, '↙');
            } else if (op === '∫' || op === '∑' || op === '∏') {
              args = string.slice(startPos + 1, endPos);
              argsList = args.split(',');
              if (argsList.length === 2) {
                under = argsList[0], over = argsList[1];
                string = this.changeBrackets(string, startPos, endPos, '↙', (this.removeSlashes(under)) + "}↖{" + over);
              }
            } else if (!((op === '/' || op === '^') && hasPower)) {
              string = this.changeBrackets(string, startPos, endPos);
              if (op === '√' && hasPower) {
                string = (this.removeSlashes(string.slice(0, i))) + "{" + (this.removeSlashes(string.slice(i, +endPos + 1 || 9e9))) + "}" + string.slice(endPos + 1);
              }
            }
          }
        }
      }
      return string;
    };

    Equation.prototype.removeSlashes = function(string) {
      return string.replace(/[\s`\\]+$/, '');
    };

    Equation.prototype.changeBrackets = function(string, startPos, endPos, prefix, middle) {
      var prev;
      if (prefix == null) {
        prefix = '';
      }
      if (middle == null) {
        middle = '';
      }
      if (!middle) {
        middle = string.slice(startPos + 1, endPos);
      }
      prev = this.removeSlashes("" + string.slice(0, startPos) + prefix);
      middle = this.removeSlashes(middle);
      return prev + "{" + middle + "}" + string.slice(endPos + 1);
    };

    Equation.prototype.insertAtCursor = function(field, value, del) {
      var endPos, scrollTop, sel, startPos;
      if (del == null) {
        del = 0;
      }
      if (document.selection) {
        field.focus();
        sel = document.selection.createRange();
        if (del) {
          sel.moveStart('character', -del);
        }
        sel.text = value;
        field.focus();
      } else if (field.selectionStart || field.selectionStart === 0) {
        startPos = field.selectionStart - del;
        endPos = field.selectionEnd;
        scrollTop = field.scrollTop;
        field.value = "" + field.value.slice(0, startPos) + value + field.value.slice(endPos, field.value.length);
        field.focus();
        field.selectionStart = startPos + value.length;
        field.selectionEnd = startPos + value.length;
        field.scrollTop = scrollTop;
      } else {
        field.value += value;
        field.focus();
      }
      return this.updateMath();
    };

    Equation.prototype.updateBox = function() {
      var char, i, k, length, power, ref, startIdx;
      if (this.keys) {
        length = this.keys.length;
        startIdx = 0;
        if (length > 1) {
          char = this.keys[length - 1];
          for (i = k = ref = length - 1; k >= 0; i = k += -1) {
            if (this.keys[i] !== char) {
              startIdx = i + 1;
              break;
            }
          }
          power = length - startIdx;
          if (power > 1) {
            this.insertAtCursor(this.inputBox, char + "^" + power, power);
          }
        }
      }
      return this.keys = [];
    };

    Equation.prototype.updateMath = function() {
      var endPos, f, func, i, indexes, j, k, l, len, len1, len2, len3, len4, m, n, o, op, ref, ref1, ref2, regex, size, startPos, token, tokens, value;
      value = this.removeSlashes(this.inputBox.value);
      ref = Equation.filters;
      for (k = 0, len = ref.length; k < len; k++) {
        f = ref[k];
        regex = new RegExp("[\\s`\\\\]*" + f, 'g');
        value = value.replace(regex, f);
      }
      value = this.findAndReplace(value, Equation.symbolregex);
      value = this.findAndReplace(value, Equation.symbol2regex);
      value = this.findAndReplace(value, Equation.letterregex);
      value = this.findAndReplace(value, Equation.letter2regex);
      value = this.findAndReplace(value, Equation.opregex);
      regex = new RegExp('/(d|∂)(x|y|z|t)', 'g');
      value = value.replace(regex, '/{$1$2}');
      ref1 = Equation.functions;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        func = ref1[l];
        value = this.parseFunction(value, func);
      }
      value = this.parseOperator(value, 'lim');
      tokens = value.split(/\s/);
      for (i = m = 0, len2 = tokens.length; m < len2; i = ++m) {
        token = tokens[i];
        if (token[0] === '\\') {
          tokens[i] = token + " ";
        }
      }
      value = tokens.join('');
      if (value) {
        ref2 = Equation.specialops;
        for (n = 0, len3 = ref2.length; n < len3; n++) {
          op = ref2[n];
          value = this.parseOperator(value, op);
        }
        indexes = this.findAllIndexes(value, '/');
        for (o = 0, len4 = indexes.length; o < len4; o++) {
          j = indexes[o];
          if (value[j - 1] === ')') {
            endPos = j - 1;
            startPos = this.findBracket(value, endPos, true);
            if (startPos != null) {
              value = this.changeBrackets(value, startPos, endPos);
            }
          }
        }
        value = this.parseOverbars(value);
        value = this.parseMatrices(value);
        value = value.replace(/&/g, '&amp;').replace(/>/g, '&gt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
        if (this.resizeText) {
          if (value.length > 160) {
            size = this.fontSize - 1.2;
          } else if (value.length > 80) {
            size = this.fontSize - 0.8;
          } else if (value.length > 40) {
            size = this.fontSize - 0.4;
          } else {
            size = this.fontSize;
          }
          this.equationBox.style.fontSize = size + "em";
        }
        this.equationBox.innerHTML = "$$" + value + "$$";
        M.parseMath(this.equationBox);
      } else {
        this.equationBox.innerHTML = this.message;
        this.equationBox.style.fontSize = this.fontSize + "em";
      }
      if (this.callback) {
        return this.callback(this.inputBox.value);
      }
    };

    Equation.prototype.keyDownHandler = function(e) {
      var key;
      switch (e.keyCode) {
        case 38:
          key = 'up';
          break;
        case 40:
          key = 'down';
      }
      if (key != null) {
        e.preventDefault();
        e.stopPropagation();
        this.insertAtCursor(this.inputBox, Equation.shortcuts[key]);
      }
      return setTimeout(((function(_this) {
        return function() {
          return _this.updateMath();
        };
      })(this)), 0);
    };

    Equation.prototype.keyPressHandler = function(e) {
      var bracketsNo, i, k, key, len, startPos, value;
      key = String.fromCharCode(e.which);
      if (/[A-Za-z]/.test(key) && !(e.altKey || e.ctrlKey || e.metaKey)) {
        clearTimeout(this.powerTimeout);
        this.powerTimeout = setTimeout(((function(_this) {
          return function() {
            return _this.updateBox();
          };
        })(this)), 300);
        return this.keys.push(key);
      } else if (key in Equation.shortcuts || key === '}') {
        e.preventDefault();
        e.stopPropagation();
        if (key === '}') {
          startPos = this.inputBox.selectionStart;
          value = this.inputBox.value.slice(0, startPos);
          bracketsNo = 0;
          for (k = 0, len = value.length; k < len; k++) {
            i = value[k];
            if (i === '(') {
              bracketsNo += 1;
            }
            if (i === ')') {
              bracketsNo -= 1;
            }
          }
          if (bracketsNo > 0) {
            return this.insertAtCursor(this.inputBox, new Array(bracketsNo + 1).join(')'));
          }
        } else {
          return this.insertAtCursor(this.inputBox, Equation.shortcuts[key]);
        }
      }
    };

    Equation.prototype.keyUpHandler = function(e) {
      var ref;
      if ((65 <= (ref = e.keyCode) && ref <= 90) && this.needBracket()) {
        return this.insertAtCursor(this.inputBox, '(');
      }
    };

    Equation.prototype.searchHandler = function() {
      if (!this.inputBox.value) {
        return this.equationBox.innerHTML = this.message;
      }
    };

    Equation.prototype.enableShortcuts = function() {
      this.inputBox.addEventListener('keydown', this.keyDownHandler, false);
      this.inputBox.addEventListener('keypress', this.keyPressHandler, false);
      return this.inputBox.addEventListener('keyup', this.keyUpHandler, false);
    };

    Equation.prototype.disableShortcuts = function() {
      this.inputBox.removeEventListener('keydown', this.keyDownHandler, false);
      this.inputBox.removeEventListener('keypress', this.keyPressHandler, false);
      return this.inputBox.removeEventListener('keyup', this.keyUpHandler, false);
    };

    Equation.prototype.enable = function() {
      this.enableShortcuts();
      this.inputBox.addEventListener('search', this.searchHandler, false);
      return this.updateMath();
    };

    Equation.prototype.disable = function() {
      this.disableShortcuts();
      this.inputBox.removeEventListener('search', this.searchHandler, false);
      return this.equationBox.innerHTML = this.message;
    };

    Equation.prototype.needBracket = function() {
      var f, k, len, ref, startPos, string;
      startPos = this.inputBox.selectionStart;
      ref = Equation.funcops;
      for (k = 0, len = ref.length; k < len; k++) {
        f = ref[k];
        string = this.inputBox.value.slice(startPos - f.length, startPos);
        if (string === f) {
          return true;
        }
      }
    };

    return Equation;

  })();

  root.Equation = Equation;

}).call(this);

//# sourceMappingURL=equation.js.map
