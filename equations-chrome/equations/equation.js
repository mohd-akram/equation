// Generated by CoffeeScript 2.3.2
(function() {
  var Equation, root,
    indexOf = [].indexOf;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Equation = (function() {
    class Equation {
      constructor(inputBox, equationBox, resizeText = false, callback = null) {
        this.keyDownHandler = this.keyDownHandler.bind(this);
        this.keyPressHandler = this.keyPressHandler.bind(this);
        this.keyUpHandler = this.keyUpHandler.bind(this);
        this.searchHandler = this.searchHandler.bind(this);
        this.inputBox = inputBox;
        this.equationBox = equationBox;
        this.resizeText = resizeText;
        this.callback = callback;
        this.fontSize = parseFloat(this.equationBox.style.fontSize);
        this.message = this.equationBox.innerHTML;
        // Initialize key buffer and timeout. Used for exponent/power shortcut.
        this.keys = [];
        this.powerTimeout = setTimeout((function() {}), 0);
        this.enable();
      }

      findAndReplace(string, object) {
        var i, j, regex;
        for (i in object) {
          j = object[i];
          regex = new RegExp(i, 'g');
          string = string.replace(regex, j);
        }
        return string;
      }

      findAllIndexes(source, find) {
        var i, k, ref, result;
        result = [];
        for (i = k = 0, ref = source.length - 1; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          if (source.slice(i, i + find.length) === find) {
            result.push(i);
          }
        }
        return result;
      }

      findBracket(string, startPos, opening = false) {
        var count, i, k, len, range, ref;
        count = 0;
        if (opening) {
          range = (function() {
            var results = [];
            for (var k = startPos; startPos <= 0 ? k <= 0 : k >= 0; startPos <= 0 ? k++ : k--){ results.push(k); }
            return results;
          }).apply(this);
        } else {
          range = (function() {
            var results = [];
            for (var k = startPos, ref = string.length; startPos <= ref ? k < ref : k > ref; startPos <= ref ? k++ : k--){ results.push(k); }
            return results;
          }).apply(this);
        }
        for (k = 0, len = range.length; k < len; k++) {
          i = range[k];
          if (string[i] === '(') {
            count += 1;
          }
          if (string[i] === ')') {
            count -= 1;
          }
          if (count === 0) {
            return i;
          }
        }
      }

      parseMatrices(string) {
        var bracketEnd, c, idx, innerBracketStart, k, rowEnd, rowStart, rows, s, table;
        s = string;
        for (idx = k = s.length - 1; k >= 0; idx = k += -1) {
          c = s[idx];
          if (s.slice(idx, idx + 2) === '((') {
            bracketEnd = this.findBracket(s, idx);
            innerBracketStart = this.findBracket(s, bracketEnd - 1, true);
            if (s[innerBracketStart - 1] === ',' || innerBracketStart === idx + 1) {
              rows = [];
              rowStart = idx + 1;
              while (true) {
                rowEnd = this.findBracket(s, rowStart);
                rows.push(s.slice(rowStart + 1, rowEnd));
                if (s[rowEnd + 1] === ',') {
                  rowStart = rowEnd + 2;
                } else {
                  break;
                }
              }
              table = `(\\table ${rows.join(';')})`;
              s = s.slice(0, idx) + table + s.slice(bracketEnd + 1);
            }
          }
        }
        return s;
      }

      parseOverbars(string) {
        var bracketEnd, bracketStart, c, idx, k, s;
        s = string;
        for (idx = k = s.length - 1; k >= 0; idx = k += -1) {
          c = s[idx];
          if (s.slice(idx, idx + 2) === '^_' && idx > 0) {
            // Remove the overbar operator
            s = s.slice(0, idx) + s.slice(idx + 2);
            if (s[idx - 1] === ')') {
              bracketEnd = idx - 1;
              bracketStart = this.findBracket(s, bracketEnd, true);
              if (bracketStart == null) {
                continue;
              }
            } else {
              bracketEnd = idx + 1;
              bracketStart = idx - 1;
              while (bracketStart - 1 >= 0 && !isNaN(Number(s.slice(bracketStart - 1, idx)))) {
                // Place start bracket appropriately if number precedes operator
                bracketStart -= 1;
              }
              s = `${s.slice(0, bracketStart)}(${s.slice(bracketStart, bracketEnd - 1)})${s.slice(bracketEnd - 1)}`;
            }
            s = this.changeBrackets(s, bracketStart, bracketEnd, '\\ov');
          }
        }
        return s;
      }

      parseFunction(string, func) {
        var endPos, i, indexes, k, len, ref, ref1, startPos;
        indexes = this.findAllIndexes(string, func);
        ref = indexes.reverse();
        for (k = 0, len = ref.length; k < len; k++) {
          i = ref[k];
          // Workaround for asin, asinh, etc.
          if (string[i - 1] === 'a' && (ref1 = func.slice(0, 3), indexOf.call(Equation.trigfunctions, ref1) >= 0)) {
            continue;
          }
          startPos = i + func.length;
          if (string[startPos] === '(') {
            endPos = this.findBracket(string, startPos);
            // Wrap function
            if (endPos) {
              string = `${this.removeSlashes(string.slice(0, i))}{\\${this.removeSlashes(string.slice(i, +endPos + 1 || 9e9))}}${string.slice(endPos + 1)}`;
            } else {
              string = `${this.removeSlashes(string.slice(0, i))}{\\${this.removeSlashes(string.slice(i))}`;
            }
          }
        }
        return string;
      }

      parseOperator(string, op) {
        var args, argsList, endPos, hasPower, i, indexes, k, len, over, ref, startPos, under;
        indexes = this.findAllIndexes(string, op);
        ref = indexes.reverse();
        for (k = 0, len = ref.length; k < len; k++) {
          i = ref[k];
          startPos = i + op.length;
          if (string[startPos] === '(') {
            endPos = this.findBracket(string, startPos);
            if (endPos) {
              hasPower = string[endPos + 1] === '^';
              // Limit underscript adjustment
              if (op === 'lim') {
                string = this.changeBrackets(string, startPos, endPos, '↙');
              // Functions with overscript and underscript
              } else if (op === '∫' || op === '∑' || op === '∏') {
                args = string.slice(startPos + 1, endPos);
                argsList = args.split(',');
                if (argsList.length === 2) {
                  [under, over] = argsList;
                  string = this.changeBrackets(string, startPos, endPos, '↙', `${this.removeSlashes(under)}}↖{${over}`);
                }
              // Change parentheses except for binary operators raised to a power
              } else if (!((op === '/' || op === '^') && hasPower)) {
                string = this.changeBrackets(string, startPos, endPos);
                // Wrap square root if followed by a power
                if (op === '√' && hasPower) {
                  string = `${this.removeSlashes(string.slice(0, i))}{${this.removeSlashes(string.slice(i, +endPos + 1 || 9e9))}}${string.slice(endPos + 1)}`;
                }
              }
            }
          }
        }
        return string;
      }

      removeSlashes(string) {
        return string.replace(/[\s`\\]+$/, '');
      }

      changeBrackets(string, startPos, endPos, prefix = '', middle = '') {
        var prev;
        if (!middle) {
          middle = string.slice(startPos + 1, endPos);
        }
        prev = this.removeSlashes(`${string.slice(0, startPos)}${prefix}`);
        middle = this.removeSlashes(middle);
        return `${prev}{${middle}}${string.slice(endPos + 1)}`;
      }

      insertAtCursor(field, value, del = 0) {
        var endPos, scrollTop, sel, startPos;
        // If IE
        if (document.selection) {
          field.focus();
          sel = document.selection.createRange();
          if (del) {
            sel.moveStart('character', -del);
          }
          sel.text = value;
          field.focus();
        } else if (field.selectionStart || field.selectionStart === 0) {
          startPos = field.selectionStart - del;
          endPos = field.selectionEnd;
          scrollTop = field.scrollTop;
          field.value = `${field.value.slice(0, startPos)}${value}${field.value.slice(endPos, field.value.length)}`;
          field.focus();
          field.selectionStart = startPos + value.length;
          field.selectionEnd = startPos + value.length;
          field.scrollTop = scrollTop;
        } else {
          field.value += value;
          field.focus();
        }
        field.dispatchEvent(new Event('input'));
        return this.updateMath();
      }

      updateBox() {
        var char, i, k, length, power, ref, startIdx;
        if (this.keys) {
          length = this.keys.length;
          startIdx = 0;
          if (length > 1) {
            char = this.keys[length - 1];
            for (i = k = ref = length - 1; k >= 0; i = k += -1) {
              if (this.keys[i] !== char) {
                startIdx = i + 1;
                break;
              }
            }
            power = length - startIdx;
            if (power > 1) {
              this.insertAtCursor(this.inputBox, `${char}^${power}`, power);
            }
          }
        }
        return this.keys = [];
      }

      updateMath() {
        var endPos, f, func, i, indexes, j, k, l, len, len1, len2, len3, len4, m, n, o, op, ref, ref1, ref2, regex, size, startPos, token, tokens, value;
        // Get value and remove trailing backslashes
        value = this.removeSlashes(this.inputBox.value);
        ref = Equation.filters;
        // Remove macros and special characters
        for (k = 0, len = ref.length; k < len; k++) {
          f = ref[k];
          regex = new RegExp(`[\\s\`\\\\]*${f}`, 'g');
          value = value.replace(regex, f);
        }
        // Display symbols, Greek letters and functions properly
        value = this.findAndReplace(value, Equation.symbolregex);
        value = this.findAndReplace(value, Equation.symbol2regex);
        value = this.findAndReplace(value, Equation.letterregex);
        value = this.findAndReplace(value, Equation.letter2regex);
        value = this.findAndReplace(value, Equation.opregex);
        // Allow d/dx without parentheses
        regex = new RegExp('/(d|∂)(x|y|z|t)', 'g');
        value = value.replace(regex, '/{$1$2}');
        ref1 = Equation.functions;
        // Parse functions
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          func = ref1[l];
          value = this.parseFunction(value, func);
        }
        value = this.parseOperator(value, 'lim');
        // Remove whitespace except after escaped tokens
        tokens = value.split(/\s/);
        for (i = m = 0, len2 = tokens.length; m < len2; i = ++m) {
          token = tokens[i];
          if (token[0] === '\\') {
            tokens[i] = `${token} `;
          }
        }
        value = tokens.join('');
        if (value) {
          ref2 = Equation.specialops;
          // Parse special operators
          for (n = 0, len3 = ref2.length; n < len3; n++) {
            op = ref2[n];
            value = this.parseOperator(value, op);
          }
          // Remove parentheses before division sign
          indexes = this.findAllIndexes(value, '/');
          for (o = 0, len4 = indexes.length; o < len4; o++) {
            j = indexes[o];
            if (value[j - 1] === ')') {
              endPos = j - 1;
              startPos = this.findBracket(value, endPos, true);
              if (startPos != null) {
                value = this.changeBrackets(value, startPos, endPos);
              }
            }
          }
          value = this.parseOverbars(value);
          value = this.parseMatrices(value);
          // Escape string
          value = value.replace(/&/g, '&amp;').replace(/>/g, '&gt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
          if (this.resizeText) {
            // Resize to fit
            if (value.length > 160) {
              size = this.fontSize - 1.2;
            } else if (value.length > 80) {
              size = this.fontSize - 0.8;
            } else if (value.length > 40) {
              size = this.fontSize - 0.4;
            } else {
              size = this.fontSize;
            }
            this.equationBox.style.fontSize = `${size}em`;
          }
          this.equationBox.innerHTML = `$$${value}$$`;
          M.parseMath(this.equationBox);
        } else {
          this.equationBox.innerHTML = this.message;
          this.equationBox.style.fontSize = `${this.fontSize}em`;
        }
        if (this.callback) {
          return this.callback(this.inputBox.value);
        }
      }

      keyDownHandler(e) {
        var key;
        switch (e.keyCode) {
          case 38:
            key = 'up';
            break;
          case 40:
            key = 'down';
        }
        if (key != null) {
          e.preventDefault();
          e.stopPropagation();
          this.insertAtCursor(this.inputBox, Equation.shortcuts[key]);
        }
        // Update the equation box immediately instead of waiting for keyup
        return setTimeout((() => {
          return this.updateMath();
        }), 0);
      }

      keyPressHandler(e) {
        var bracketsNo, i, k, key, len, startPos, value;
        key = String.fromCharCode(e.which);
        if (/[A-Za-z]/.test(key) && !(e.altKey || e.ctrlKey || e.metaKey)) {
          clearTimeout(this.powerTimeout);
          this.powerTimeout = setTimeout((() => {
            return this.updateBox();
          }), 300);
          return this.keys.push(key);
        } else if (key in Equation.shortcuts || key === '}') {
          e.preventDefault();
          e.stopPropagation();
          // Close all brackets
          if (key === '}') {
            startPos = this.inputBox.selectionStart;
            value = this.inputBox.value.slice(0, startPos);
            bracketsNo = 0;
            for (k = 0, len = value.length; k < len; k++) {
              i = value[k];
              if (i === '(') {
                bracketsNo += 1;
              }
              if (i === ')') {
                bracketsNo -= 1;
              }
            }
            if (bracketsNo > 0) {
              return this.insertAtCursor(this.inputBox, new Array(bracketsNo + 1).join(')'));
            }
          } else {
            return this.insertAtCursor(this.inputBox, Equation.shortcuts[key]);
          }
        }
      }

      keyUpHandler(e) {
        var ref;
        // Add bracket after functions
        if ((65 <= (ref = e.keyCode) && ref <= 90) && this.needBracket()) {
          return this.insertAtCursor(this.inputBox, '(');
        }
      }

      searchHandler() {
        if (!this.inputBox.value) {
          return this.equationBox.innerHTML = this.message;
        }
      }

      enableShortcuts() {
        this.inputBox.addEventListener('keydown', this.keyDownHandler, false);
        this.inputBox.addEventListener('keypress', this.keyPressHandler, false);
        return this.inputBox.addEventListener('keyup', this.keyUpHandler, false);
      }

      disableShortcuts() {
        this.inputBox.removeEventListener('keydown', this.keyDownHandler, false);
        this.inputBox.removeEventListener('keypress', this.keyPressHandler, false);
        return this.inputBox.removeEventListener('keyup', this.keyUpHandler, false);
      }

      enable() {
        this.enableShortcuts();
        this.inputBox.addEventListener('search', this.searchHandler, false);
        return this.updateMath();
      }

      disable() {
        this.disableShortcuts();
        this.inputBox.removeEventListener('search', this.searchHandler, false);
        return this.equationBox.innerHTML = this.message;
      }

      needBracket() {
        var f, k, len, ref, startPos, string;
        startPos = this.inputBox.selectionStart;
        ref = Equation.funcops;
        for (k = 0, len = ref.length; k < len; k++) {
          f = ref[k];
          string = this.inputBox.value.slice(startPos - f.length, startPos);
          if (string === f) {
            return true;
          }
        }
      }

    };

    Equation.shortcuts = {
      '[': '(',
      ']': ')',
      "'": '*',
      ';': '+',
      '`': "'",
      'up': '^(',
      'down': '_'
    };

    Equation.symbolregex = {
      '===': '≡',
      '~~': '≈',
      '!=': '≠',
      '=/=': '≠',
      '>=': '≥',
      '!<': '≮',
      '!>': '≯',
      '<-': '←',
      '->': '→',
      '<==': '⇐',
      '==>': '⇒',
      '\\+/-': '±',
      '\\*': '×',
      '\\^\\^': '\u0302'
    };

    Equation.symbol2regex = {
      '<=': '≤'
    };

    Equation.letterregex = {
      'Alpha': 'Α',
      'alpha': 'α',
      'Beta': 'Β',
      'beta': 'β',
      'Gamma': 'Γ',
      'gamma': 'γ',
      'Delta': 'Δ',
      'delta': 'δ',
      'Epsilon': 'Ε',
      'epsilon': 'ε',
      'Zeta': 'Ζ',
      'zeta': 'ζ',
      'Eta': 'Η',
      'Theta': 'Θ',
      'theta': 'θ',
      'Iota': 'Ι',
      'iota': 'ι',
      'Kappa': 'Κ',
      'kappa': 'κ',
      'Lambda': 'Λ',
      'lambda': 'λ',
      'Mu': 'Μ',
      'mu': 'μ',
      'Nu': 'Ν',
      'nu': 'ν',
      'Xi': 'Ξ',
      'xi': 'ξ',
      'Omicron': 'Ο',
      'omicron': 'ο',
      'Pi': 'Π',
      'pi': 'π',
      'Rho': 'Ρ',
      'rho': 'ρ',
      'Sigma': 'Σ',
      'sigma': 'σ',
      'Tau': 'Τ',
      'tau': 'τ',
      'Upsilon': 'Υ',
      'upsilon': 'υ',
      'Phi': 'Φ',
      'phi': 'φ',
      'Chi': 'Χ',
      'chi': 'χ',
      'Psi': 'Ψ',
      'Omega': 'Ω',
      'omega': 'ω',
      'inf': '∞'
    };

    Equation.letter2regex = {
      'eta': 'η',
      'psi': 'ψ',
      'del': '∇'
    };

    Equation.opregex = {
      'lim': '\\lim',
      'sqrt': '√',
      'int': '∫',
      'sum': '∑',
      'prod': '∏'
    };

    Equation.specialops = ['^', '_', '/', '√', '∫', '∑', '∏'];

    Equation.functions = ['exp', 'log', 'ln', 'sinc'];

    Equation.trigfunctions = ['sin', 'cos', 'tan', 'csc', 'sec', 'cot'];

    (function() {
      var func, k, len, ref, results;
      ref = this.trigfunctions;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        func = ref[k];
        this.functions.push(func);
        this.functions.push(`a${func}`);
        this.functions.push(`${func}h`);
        results.push(this.functions.push(`a${func}h`));
      }
      return results;
    }).bind(Equation)();

    Equation.funcops = Object.keys(Equation.opregex).concat(Equation.functions);

    Equation.filters = ['\\$', '\\{', '\\}', 'bo', 'it', 'bi', 'sc', 'fr', 'ov', 'table', 'text', 'html', ',', ':', ';'];

    return Equation;

  }).call(this);

  root.Equation = Equation;

}).call(this);

//# sourceMappingURL=equation.js.map
